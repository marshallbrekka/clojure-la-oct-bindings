<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>reveal.js - The HTML Presentation Framework</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/solarized_dark.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>


    

    <!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
	<section>
	  <h1>Clojure at ReadyForZero</h1>
          <p>Mature and large Clojure codebase (100K+ lines)</p>
          <p>Wide range of uses (Web, Daemon, Infrastructure, PCI)</p>
	</section>

        <section>
          <h1>Topics</h1>
          <ol>
            <li>Why Clojure?</li>
            <li>Tips for Clojure in production</li>
          </ol>
        </section>

        <section>
	  <h1>Why Clojure?</h1>
          <ul>
            <li class="fragment">Functional programming with
              immutability-by-default <em><small>- eliminates whole classes of bugs</small></em></li>
            <li class="fragment">Pure functions are easy to reason about, and easy to test</li>
            <li class="fragment">Concurrency for “free”</li>
          </ul>
          <aside class="notes">
            <ul>
              <li>immutability - easily parralize pure function</li>
              <li>bypass issues common to multi-thread</li>
            </ul>
          </aside>
	</section>
        

        <section>
          <section>
	    <h2>Why Clojure at ReadyForZero?</h2>
            <ul>
              <li class="fragment">Powerful language lets our small team move fast
                <em><small>- faster than companies with more resources than us</small></em></li>
              <li class="fragment">Reap all the benefits of the JVM</li>
              <li class="fragment">Simple data flows, easy to understand and modify</li>
            </ul>
            <aside class="notes">
              <ul>
                <li>yodlee, payments, PCI, infrastructue</li>
                <li>java/jvm libraries, battle tested-memory management,
                  etc</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>Java Interop Benefits</h2>
            <ul>
              <li>Don't have to reinvent the wheel if it exists in Java</li>
              <li>Very easy to use battle-tested Java libraries</li>
              <li>... and idiomatic Clojure wrappers are easy to find</li>
            </ul>
            <table>
              <thead>
                <tr>
                  <th><strong>Clojure</strong></th>
                  <th>Java</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>carmine</strong></td>
                  <td>Redis</td>
                </tr>
                <tr>
                  <td><strong>ring</strong></td>
                  <td>Jetty</td>
                </tr>
                <tr>
                  <td><strong>clj-time</strong></td>
                  <td>Joda (time library)</td>
                </tr>
                <tr>
                  <td><strong>quartzite</strong></td>
                  <td>Quartz Schedule (task scheduling)</td>
                </tr>
              </tbody>
            </table>
          </section>

	</section>

        
        <section>
	  <h2>Easy, Readable Dataflows</h2>
          <h5>-&gt; and -&gt;&gt; macros let us express our business logic in a clear and succinct way</h5>
          <p>What many think that lisp looks like (eww, parentheses!)</p>
	  <pre><code data-trim contenteditable class="clojure">
(defn get-total-spent
  "Returns total spent for the given transactions"
  [transactions]
  (reduce + (map :amount (filter is-debit-type transactions))))
	  </code></pre>
          <p class="fragment">-&gt;&gt; makes the data flow easier to understand and modify</p>
	  <pre class="fragment"><code data-trim contenteditable class="clojure">
(defn get-total-spent
  "Returns total spent for the given transactions"
  [transactions]
  (->> transactions
       (filter is-debit-type)
       (map :amount)
       (reduce +)))
          </code></pre>
          <aside class="notes">
            Threading macros (thread-first, thread-last)
          </aside>
	</section>


        <section>
	  <h2>Easy, Readable Dataflows</h2>
          <p>->> also lets you build functions concatenatively in the REPL</p>
          <p>immutability + s-expressions = <em>quick development</em></p>

          <pre><code data-trim contenteditable  class="clojure">
> (->> "test" println)
test
> (->> "test" (println "a"))
a test
> (->> "test" (str "a ") (println "here is "))
here is a test
          </code></pre>
          <aside class="notes">
            <p>immutability + s-expressions = quick. python and
              ruby <em><strong>cannot</strong></em> do as easily</p>
          </aside>
	</section>

        <section data-background-video="lib/concat_repl.mp4">
<!--          <p>Demo of concat programming</p>
            <iframe data-autoplay
                  src="https://asciinema.org/api/asciicasts/13761?loop=true&amp;size=medium"
                  id="asciicast-iframe-13761" name="asciicast-iframe-13761"
                  scrolling="yes" class="stretch"></iframe>-->
        </section>

        <section data-background-video="lib/qa_repl.mp4">
          <aside class="notes">
            <ul>
              <li>start browser session</li>
              <li>query for qa elements</li>
              <li>perform actions on those qa elements</li>
              <li>Write full test based on REPL</li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>Macros - the good</h2>
          <p>Powerful for creating abstractions, DSLs, new syntax</p>
          <pre class="fragment"><code data-trip contenteditable  class="clojure">
(defvalidatedfn login
  "Given a map with keys :email and :password attempts to login the
   user and returns an :ok or :error response"
  [params]
  [{:email String :password String} => {:response (s/enum :ok :error)}]
  (if (do-login (:email params) (:password params))
    {:response :ok}
    {:response :error}))
          </code></pre>
          <aside class="notes">
            <ul>
              <li>Language level construct.</li>
              <li>extends the standard defn form to allow for validation</li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>Why Clojure Recap</h2>
          <ul>
            <li>Build up logic iteratively with simple primitives</li>
            <li>Get instant feedback</li>
            <li>Very expressive, at the same level as the langauge</li>
          </ul>
        </section>

        <section>
          <h1>Tips for using Clojure in production</h1>
        </section>

        <section>
          <h2>Macros - the bad</h2>
          <ul>
            <li class="fragment">Limited composability, can’t be used in higher-order functions</li>
            <li class="fragment">Better to use less macros and DLSs in favor of functions and maps</li>
          </ul>
          <pre class="fragment"><code data-trip contenteditable  class="clojure">
(defendpoint web2 [:post "/authed/graph"]
  (in {:type string?
       :account string?})
  (out (with-valid-control
         {}))
  (return {:keys [type account]}
          (if-let [graph-data (prog/get-graph (user/me) type account)]
            (with-control {:result "ok"} graph-data)
            (with-control {:result "not-found"} nil))))
          </code></pre>
          <aside class="notes">
            <ul>
              <li>do not compose as well as functions (not higher order)</li>
              <li>difficult to reason about</li>
              <li>DSLs and macros violated principle-of-least-surprise, we avoid
              them, exceptions are reviewed</li>
              
              <li>return block, wtf are the args to this, this
                looks nothing like a function (but it is!!!)</li>
              </ul>
          </aside>
        </section>

        <section>
          <h2>Macros - the bad</h2>
          <p>Instead use standard functions and maps</p>
          <pre><code data-strip contenteditable  class="clojure">
(add-handler :mobile "progressgraph" "1" "progressgraph"
  {:fn progress-graph
   :in-examples [{:account-id 1}]
   :out-examples [(iface/response :ok {:current  [{:x 11.2 :y 20}
                                                  {:x 13 :y 10}
                                                  {:x 14 :y 0}]
                                       :history  [{:x 1 :y 50}
                                                  {:x 4 :y 40.34}
                                                  {:x 10 :y 35.0}]})
                  (iface/response :error ["something wrong"])]})
          </code></pre>
        </section>

        <section>
          <h2>Use protection (against clojures power)</h2>
          <p>Conventions help</p>
          <p class="fragment">Guardrails, when convention isn’t enough</p>
          <aside class="notes">
            Clojure will happily let you “shadow” core
            functions with local variables. we disallow this in our coding
          guidelines
          </aside>
        </section>

        <section>
          <h2>Most common bug</h2>
          <p>Missing/misspelled keys</p>
          <pre><code data-strip class="clojure">
(def data {:my-key "my value"})
(:my-jey data) ;; nil, doesn't throw error              
          </code></pre>
          <div class="fragment">
          <p>We guard against them using -!&gt; and friends</p>
          <pre><code data-strip class="clojure">
(def data {:my-key "my value"})
(-!> data :my-jey) ;; got nil value for key, Throws Exception!
          </code></pre>
          </div>
        </section>

        <section>
          <h2>What does function in/out look like?</h2>
          <p>For trusted entry points, docstrings usually suffice</p>
          <pre><code class="clojure" data-strip>
(defn user-accounts 
  "Given a user id, returns a list of account objects, each 
   with the keys :id, :balance, :name, :created-date"
   [user-id]
   ...)
          </code></pre>
          <p class="fragment">For unstrusted entry points - Prismatic Schema to
            the rescue!</p>
          <aside class="notes">
            We added the primastic schema library as a language level feature
            for our defvalidatedfn implimentation
          </aside>
        </section>

        <section>
          <h2>Use Paredit!</h2>
          <h3>Plugin available for many editors</h3>
          <p>Auto-manage parenthesis balance</p>
          <p>Easy manipulation of s-expression form</p>
        </section>

        <section data-background-video="lib/paredit.mp4">
          <!-- paredit demo -->
        </section>

        <section>
          <h1>Wrap up</h1>
          <ul>
            <li>Favor maps/functions over macros</li>
            <li>Have strict team conventions (docstrings!)</li>
            <li>Protect against missing/mispelled keys with -!&gt;</li>
            <li>Use Paredit</li>
          </ul>
          <p>&nbsp;</p>
          <p><small>Marshall Brekka - <em>marshall.brekka@avant.com</em></small></p>
          <p><small>Benny Tsai - <em>benny.tsai@avant.com</em></small></p>
        </section>
      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,

      transition: 'slide', // none/fade/slide/convex/concave/zoom

      // Optional reveal.js plugins
      dependencies: [
      { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'plugin/zoom-js/zoom.js', async: true },
      { src: 'plugin/notes/notes.js', async: true }
      ]
      });

    </script>

    <script>
      Reveal.addEventListener( 'slidechanged', function( event ) {
      function toArray( o ) {

      return Array.prototype.slice.call( o );
      
	}
      
      toArray( event.currentSlide.querySelectorAll( 'iframe[src*="asciinema.org/api/asciicasts/"]' ) ).forEach( function( el ) {
      if( el.hasAttribute( 'data-autoplay' ) ) {
          el.contentWindow.postMessage(["asciicast:play"], '*' );
        }
      });
      // event.previousSlide, event.currentSlide, event.indexh, event.indexv
      } );

    </script>

  </body>
</html>
